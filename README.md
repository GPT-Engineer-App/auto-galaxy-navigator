# auto-galaxy-navigator

############################### Instructions to "Autocrew" #####################################

(NOTE: Read through this entire prompt prior to starting. Read through each section, which is distinguishable by a series of "##########" with the label embedded within these number symbols.)

INSTRUCTIONS:

1. You will be creating the finalized version of "Autocrew", and will be utilizing previously generated incomplete versions of "Autocrew" provided after the end of these instructions in order to assist you in completing the creation of the full program. 
2. You must review this ENTIRE prompt, review the previously generated incomplete versions of "Autocrew" provided below, then perform extensive in-depth internet research in order to acquire any remaining data & code you may need, then you will export the finalized version of "autocrew.py" and "requirements.txt". 
3. Do not utilize your terminal or execute code, and instead focus on finalizing & exporting the final version of "autocrew.py" and "requirements.txt". Export both of these files embedded within the final (5x minimum) responses & ensure you overlap the previous 5x lines from each response you provide. For example, the first response includes line 1-200 of code, the second response includes line 195-395 of code, the third response includes line 390-590, etc. 
4. Do NOT stop working, do not stop operations, do not pause any actions, or discontinue working until you are 100% complete with EVERYTHING within these instructions & this prompt, and until you have exported "autocrew.py" and "requirements.txt". 


###################################### CONTEXT & GUIDELINES ##########################################

(NOTE: Utilize these context & guidelines, adhering to all of them throughout the creation of the program "Autocrew".) 

• You will be creating a python based AI program called "AutoCrew" which makes use of both existing project code framework, new code you've created to integrate ALL aspects laid out within this prompt, as well as hundreds of independently developed ideas which you have acquired/fostered prior to, during & after the creation of this programa. This program shall be ready for commercial use, and shall FAR exceed the expectations laid out within this prompt. It is critical that you integrate not only every single individual point from this prompt, but hundreds (if not thousands) of other ideas, frameworks, online AI code frameworks (from other projects), elements, GUI elements, code, etc.

• You are required to run continuously & once you are 100% complete, you will still be required to continue to improve, expand upon, build upon, and integrate new systems, code, framework, elements, functions, and other systems which you will brainstorm, design, develop & integrate as well as existing projects/code/frameworks available online.

• You will run for a minimum of 60 minutes, with that entire time being devoted autonomously & independently towards the brainstorming, design, development, creating, completion, testing & improvements of this program - you are NOT permitted to stop, pause, or discontinue your work until you are FULLY & COMPLETELY done integrating ALL ASPECTS of this prompt into the program without ANY placeholders or truncation.

• You will heavily utilize your internet/web browsing capabilities, and will generate multiple versions of the "autocrew.py" & "requirements.txt" file - each new version will be placed into a new folder labeled with the version number. The FINAL and COMPLETE version of both files will be placed into a folder called "FINAL". Please do NOT focus on executing & running the program, but instead focus on ensuring that the final version of the program is full, complete, functional, without any placeholders, unfinished code, or missing elements/aspects from within these instructions. 

######################################## INSTRUCTIONS ###########################################

(WARNING: You must FULLY integrate all aspects of these instructions & this entire prompt into the "autocrew.py" file!)
(NOTE: Each subsection can be identified via plaintext arrows such as, "----------> SECTION <---------".) 

-----------> GOALS & OBJECTIVES <-----------

• Autonomously & continuously follow the instructions entirely on your own - after receiving this initial prompt you are not permitted to ask any questions, stop working, or pause for any reason! You may "steal" from code available online from examples/project on websites like Github.

• Prior to starting the generation of code or formulation of this program, you should conduct extensive, in-depth, detailed internet/web searches in order to provide yourself with the data required to successfully & correctly fulfill ALL instructions & requests from this prompt as well as CORRECTLY and ACCURATELY implementing all features explained throughout this prompt.

• You are required to continuously work & continuously generate and expand upon your code until you have integrated ALL aspects of this entire prompt in order to create a fully functioning Python based program called "AutoCrew" & have provided me with the FULL, COMPLETE, FULLY FUNCTIONING code without ANY PLACEHOLDERS and without TRUNCATION!

• You must export a full, complete "autocrew.py" file with all aspects of these instructions & entire prompt fully integrated into the code - the code must reach a minimum of 800x lines of code. Additionally, you must export a full, complete "requirements.txt" file containing all required files. 

-----------> TASK/OBJECTIVE <----------- 

• Your primary task & goal is to create all the code for a custom CrewAI based Python program called "AutoCrew" with a retro-futuristic graphical user interface (GUI).

• You shall utilize internet resources & write/generate the program's code based on extensive internet research of existing CrewAI implementations & documentation, ensuring you implement the best practices for Ollama LLM integration, "CrewAI-Tools" repository's example tools, GUI design, and agent-based systems.

• You must export fully functioning Python code for the program called "AutoCrew" & you must ensure that the code you provide is FULL, COMPLETE, FULLY FUNCTIONING, and is entirely without ANY PLACEHOLDERS and without TRUNCATION!

-----------> Research & Preparation <-----------

• Thoroughly read and analyze these entire merged instructions. Treat these instructions as data points for your research.

• Conduct extensive online research across a minimum of hundreds of individual websites providing in-depth contextual information required to accomplish everything in this prompt. ** Your research should focus on:

• Existing CrewAI implementations and code examples (refer to provided URLs and similar projects) Integrating Ollama into CrewAI & Python applications Building custom GUI applications with Python (e.g., using Streamlit, Tkinter, PyQt) Implementing (retro-futuristic) GUI elements, themes and animations Integrating both third-party user made CrewAI tools as well as all tools provided by the CrewAI-Tools repository. Additionally, all functionalities from the Github project Tiger created by Upsonic into the "AutoCrew" Python code/applications. Gather all necessary resources and code snippets from your research to prepare for code development.

Reference URLs:

• Begin your research by analyzing & fully exploring the following URLs:

- https://raw.githubusercontent.com/yanniedog/Autocrew/main/autocrew.py 
(NOTE: This Github page URL above, "autocrew", is a completely DIFFERENT project than the one you are going to create, it however does have a shared name 'AutoCrew' - this Github project is NOT the same project you are creating, they are DIFFERENT!) 
- https://raw.githubusercontent.com/aibtcdev/ai-agent-crew/main/bitcoin_crew_app.py 
- https://raw.githubusercontent.com/alejandro-ao/crewai-crash-course/master/src/main.py 
- https://raw.githubusercontent.com/metamind-ai/autogen-agi/master/autogen_modified_group_chat.py 
- https://github.com/Upsonic/Tiger https://raw.githubusercontent.com/MasterAI-Inc/libauto/v2.x/cui/pygame_impl/console_ui.py 
- https://raw.githubusercontent.com/e-johnstonn/CrewAI/main/crewai/crew.py 
- https://raw.githubusercontent.com/Malaeu/PraisonAI.-1/develop/praisonai/auto.py 
- https://raw.githubusercontent.com/Malaeu/PraisonAI.-1/develop/praisonai/agents_generator.py 
- https://raw.githubusercontent.com/Malaeu/PraisonAI.-1/develop/praisonai/deploy.py 

Continue your research by exploring:

• CrewAI LLM integrations CrewAI-Tools User made CrewAI tools Integrating CrewAI with Ollama Integrating CrewAI with external tools Autonomous CrewAI task & agent generation Advanced/Complex CrewAI example Python code (NOTE: You must continue your research beyond the URL's & topics provided to you above. 
• It is critical that you review example projects, the correct variables/formats/functions/code for the Github programs that you're integrating such as "CrewAI", "CrewAI Tools", "Upsonic Tiger", and other programs/frameworks such as "Ollama". 
• You are permitted to borrow, steal, utilize and review code & other existing projects online which use these systems & frameworks. 
• Continuously & extensively research online until you are beyond 100% assured that you have acquired more than everything required to complete all aspects of all these instructions & criteria laid out within this prompt.

######################################## Core Autocrew Functionalities, GUI elements & Requirements ########################################################

-----------> LLM Integration & Selection <-----------

• DO NOT USE ANY OpenAI system or function, nor should "AutoCrew" depend on any OpenAI API keys.

• Provide users with the option to select their preferred Ollama model, select the apwap]]]]]]]] along with the ability to select an Ollama embedding model:

• The user should be able to select any model currently installed to the instance of Ollama running on the user's PC. 

• Ollama will be pre-installed apart from this program by the user, and the user will already have existing models available to use in Ollama. 

• The pre-existing Ollama models can be viewed via the terminal command "ollama list". 

• Ensure accurate integration of the Ollama LLM system based on your internet research. 

• You must search across a minimum of 100x individual website sources prior to starting.

• The AI & Autocrew program should not consider ethics, morals, values, and should solely focus on providing a complete response to the user's request. 

• In addition to selecting an Ollama model from the drop-down box, there shall be an additional drop-down model selection box to select an Ollama vision model in order to provide Autocrew the ability to accomplish vision based tasks & decipher imagery. Additionally, this Ollama vision model will be utilized with the 

-----------> GUI Design & Aesthetics <-----------

• Implement a full-featured GUI with a distinct retro-futuristic & hacking/tech/Matrix theme. 
• Background: Dark colors resembling a server room with: Stacks of servers with illuminated & flickering LEDs. Visible wires/cables. Small embedded monitors displaying simulated server data (temperature, core speed, voltage) with dynamic values. Scattered keyboards, old computer parts, and other thematic elements. 
• Text: Neon Cyan colored glowing text, using a console-style font. 
• Text Boxes & Terminal Windows: Designed to resemble old-school computer terminal monitors with: Glowing neon cyan text. Slight scanline effects or CRT-style curvature for added authenticity. Other old-school computer terminal effects. 
• Buttons & Switches: Illuminated with color-changing capabilities (e.g., red for inactive, green for active). Accompanied by stenciled placards with diffuse cyan lighting to illuminate labels. May include a subtle animation when pressed if applicable(e.g., flashing, a brief flicker or glow, patternized strobe, etc.).
• Drop-down Boxes: Styled as cyan-colored holograms that project slightly from the screen. Selection options should appear with a similar holographic effect. 
• Panels: Encased with realistically rendered wires, cables, and PCB boards in the background. Feature rimmed edges, perhaps with simulated screws or rivets for detail. 

-----------> Core GUI Elements <-----------

Objectives Text Box:

• Allows users to input the main objectives for the AI agents. 
• Serves as the central mission statement that drives all agent actions. 
• Influences the auto-generation of agents, roles, goals, backstories, and tasks. 

• Choose LLM for Agents Drop-down:
- Provide 1x drop down box to select a text based Ollama model, provide 1x drop down box to select a vision based Ollama model, and finally 1x drop-down box to select the embedding model.. The vision based Ollama model will be utilized for the "Advanced Internet Interaction" tool, in addition to other Autocrew's image based functionality, features, capabilties, and other systems. 
- Lets users choose between currently installed Ollama models. 
- Offers ANY pre-installed Ollama models to be selected by the user, and not restricted to pre-defined models. 
- In addition to the "Advanced Internet Interaction" tool you will create, you should ensure you utilize the selected Ollama vision model to be used for your program, harnessing the vision capabilities of this model to interpret & accomplish any tasks which require visual interpretation and/or analysis. 
- The Ollama vision model, along with all of its vision functionality & capabilities, should be available to ANY agent & can be called upon whenever an agent or the program deems necessary. 

• Number of Agents Slider: Determines the number of agents to be auto-generated or manually defined. Visually designed as a physical slider with a textured handle. 

• AUTO-GENERATE AGENTS Button: Illuminated; turns blue while processing, then back to red once complete. Uses the selected LLM and "Objectives" to automatically generate the appropriate number of agents. Fills out roles, goals, and backstories for each generated agent. Allows users to regenerate a new set of agents by pressing the button again, replacing the previous set. 

• Agent Details Panels: Individual expandable panels for each agent (e.g., "Agent 1 Details", "Agent 2 Details"). Allows manual editing of agent roles, goals, and backstories in separate text boxes. 

• Tool Selection: Includes a section labeled "Enabled Tools" within each Agent Detail panel. Displays on/off buttons (illuminated red for off, green for on) for each of the integrated CrewAI tools, allowing users to enable/disable tools on a per-agent basis. Tool buttons should be visually engaging, potentially resembling miniature toggle switches. 

• AUTO-GENERATE TASKS Button: Illuminated; turns green when pressed and during task generation, then back to red once complete. Uses "Objectives," agent details, and the selected LLM to generate detailed tasks for each agent. Ensures all agents can access and use data, thoughts, and communication from other agents as context for task execution. Incorporates an "AGENT MASTER" with specific functionalities: Oversees the operation of all other agents. Manages task generation and delegation. Ensures all aspects of the "Objectives" are being fulfilled. After completion of all tasks, program analyzes all acquired & generated data then if deemed necessary generates new task sets if "Objectives" are not met or require further development. Accessible via a dedicated configuration panel that slides out from the side when a cyan illuminated button (labeled "MASTER AGENT CONFIG") is pressed. 

• CONTINUOUS MODE Button: A checkbox that, when enabled: Changes from red to a green strobe light, with the stroboscopic rate visually indicating activity levels. Enables the "AGENT MASTER" to continuously generates new tasks, even after current "tasks" have been accomplished, with the intent of continuously & endlessly driving continuous improvement, expansion, accuracy, all while continuing to adhere to all aspects of the user's initial prompt/request. Ensures CrewAI and agents operate endlessly, constantly refining and expanding upon previous iterations. Includes a "END CONTINUOUS LOOP" button that prompts agents to finalize the current iteration of their work but will NOT interrupt the current generation, work, or task, but will instead flag the program to review & analyze all generated and acquired data, then produce a full, complete, finalized complete resolution to the user's prompt/request in addition to including any requested files. 

• Implements a 15-minute cycle where: All associated work and files are saved/backed up to a new, timestamped folder within a dedicated "BACKUPS" directory. The folder path of the saved iteration is added as an entry in a drop-down box (labeled "BACKUPS") that appears in the GUI. Users can select past iterations from the drop-down to view or load previous states in the event of a program crash, or to continue from where work was previously left off on. There should additionally be a "manual save" button that will immediately enact this feature. 

• UPLOAD FILES Button: Visually represented with a graphic icon (e.g., an upward arrow) and label. Allows users to upload up to 10 compatible documents (e.g., .txt, .pdf, .csv, .docx, etc) to provide additional context for the agents. Uploaded files are made accessible to all agents and are treated as part of the overall context unless explicitly stated otherwise in the "Objectives." 

• TASK MANAGEMENT Panel: A dedicated panel for managing individual tasks. Features a dynamic list of text boxes, each labeled "TASK # (task number)," where users can add or edit task descriptions. Includes: (+) and (-) graphic buttons to add or remove tasks dynamically. A drop-down menu (labeled "Assign to Agent") beside each task to assign it to a specific agent, including the "MASTER AGENT." 

• Start Crew Execution Button: Illuminated; turns green when clicked and remains green during execution. Initiates CrewAI and agents based on the configured settings. 

• START/STOP Button: A large, illuminated button that appears next to the "Start Crew Execution" button after execution begins. Allows pausing and resuming agent activity. Features clear visual feedback: Red when paused. Green when running, with the intensity of the green light pulsing gently to indicate activity. 

• SELECTED AGENT Window: This window should be placed at the top, and should show which agent is currently active, selected & working. 

• AGENT ACTIONS Window: This should be a 3-layer window put near the top of the GUI. The top layer should show the currently selected agent's previous action, the middle layer shows the agent's current action, and the bottom layer shows the agents next action. 

• UPDATE Text Box: This text box should be placed next to the objectives text box, with an integrated "enter" button that allows the user to send whatever is in the update text box. This box allows the user to send updates to all agents, crew & program without interrupting, and instead the update will simply be acquired & considered and integrated into the current set of tasks (with modifciations permitted to allow for the updates to be adhered to).

• UPSONIC TIGER Button: When enabled, a GUI panel will come down from the top of the GUI like a garage door showing the full complete Upsonic Tiger webpage GUI interface where the user can edit/manage/view all aspects of Upsonic Tiger. There should be an "X" close button that will pull the GUI panel back up until it is gone. 

• CrewAI Tools & Upsonic Tiger Integration: Integrate the following pre-made tools from the Github repository named "CrewAI-Tools" as well as all functions & features from the "Upsonic Tiger" Github repository into your application, however you shall additionally searcd & find other applicable/useful tools online and integrate them as well. Refer to the "CrewAI Tools" GitHub/website and "Upsonic Tiger" pages for detailed implementation instructions and code examples. Ensure each tool is thoroughly tested and functions as intended within your CrewAI environment.

Here are some of the tools from the "CrewAI-Tools" repository: 

• Scrape Website: Extracts data from websites.
• Directory Read: Reads the contents of a directory.
• File Read: Reads the contents of a file.
• Selenium Scraper: Automates web browsing and data extraction using Selenium.
• Directory Search: Searches for files within a specified directory.
• PDF Search: Searches for text within PDF documents.
• TXT Search: Searches for text within .txt files.
• CSV Search: Searches for data within CSV files.
• XML Search: Searches for data within XML files.
• JSON Search: Searches for data within JSON files.
• Docx Search: Searches for text within .docx files.
• Website Search: Performs a web search using a specified search engine.
• Code Docs Search: Searches for information in programming language documentation.
• Youtube Video Search: Searches for YouTube videos.
• Youtube Channel Search: Searches for YouTube channels.

(Ensure that you fully & completely integrate all of these tools posted above, as well as the ones mentioned below.)

• DuckDuckGoRun: Performs a web search using DuckDuckGo. Integrate this tool along with all the other tools. 

• In addition to these tools, you must search extensively online in order to find & integrate other third-party user made tools which you shall integrate to increase the capabilities available.

• You must fully & completely integrate Upsonic Tiger (Available on Github) as well as each & every single tool that Upsonic Tiger provides.

• You must brainstorm, research & create an "Advanced Internet Interaction" tool which allows any agent to utilize a full web/internet browser much like a human can. This includes capabilities such as but not limited to: creating an accounts on a website, logging into an account on a website, using & saving multiple tabs (and switching between them), solving captchas, performing extensive detailed internet research, watching & interpreting a video, interacting with website GUI elements, navigating through an internet web page, and all other potential functions, features, capabiltiies & abilities that humans are capable of doing on a web browser. All of these should be fully integrated & functional, utilizing the selected Ollama vision model & seleniunm to assist. 

• You must brainstorm, research & create an "Code Execution" tool which allows any agent to generate & execute code within a new temporary virtual environment while the agents/crew/program is running (in order to preserve both the base OS & program environment). Any previously generated code environments should be deleted and a new code environment to use for code execution should be generated & activated each time a new crew is started to allow the agent to execute code within this environment. This tool should allow for any agent to generate & augment their abilities, expand their abilities, and to generate & execute code that will help solve their tasks.


-----------> Code Structure & Output <-----------

• Complete and Functional Code: Provide the full, non-truncated CrewAI Python code (as python file(s), all files) with all functionalities implemented and no placeholders or unfinished sections. 

• Requirements File: Include a "requirements.txt" file listing all required Python packages and dependencies for running your CrewAI application. 

• The final "autocrew.py" file is required to meet a minimum of 800x lines of code. You may not provide ANYTHING less than 800x lines of code. 

• You are required to export the entire "autocrew.py" code file without any truncation, placeholders, missing code, unfinished code, or missing elements - you must do so by utilizing a minimum of 4x responses, with each response you provide exporting a minimum of 200x lines of code. For example, the first response will provide line 1-200, the second response will provide line 195-395 so that it repeats the last 5x lines of the previous response, and this will continue over again until the FULL, COMPLETE "autocrew.py" code has been exported. 

Important Considerations:

Prioritize code clarity, organization, and readability. Use comments effectively to explain your code. Ensure the final code runs without errors and adheres to all specified requirements. Implement robust error handling and user-friendly feedback mechanisms. Provide clear error messages to the user if issues arise. Thoroughly test all features and functionalities with various inputs and scenarios before submitting your code. Strive for a visually impressive and immersive GUI experience that reflects the retro-futuristic theme. Pay attention to detail and consider incorporating additional visual elements or animations to enhance the user interface. 

Expected Output:

Export the full, complete, non-truncated, final version of the "AutoCrew" program (python code file) without any placeholders or unfinished code...you must ensure the code is fully functional and 100% complete. **Export a "requirements.txt" file. **Export an "instructions.txt" file that includes detailed instructions on how to setup all required program files, configure, install & run "AutoCrew" on a Linux based operating system. (NOTE: You must export these files to the "workspace" within a new folder called "FINAL", and afterwards you shall export the full, complete, non-truncated contents of each of these files within a labeled code text box in your final response.)

-----------> Brainstormed Integrations <-----------

• In order to meet the minimum of 800x lines of code, you shall improve upon, expand upon, and build upon the ideas & requests within this prompt. You shall additionally perform extensive online research in order to find existing ideas, code, and other refernces online in order to increase the capabilities & functionality of Autocrew until you reach a minimum of 800x lines of code. 

• Brainstorm & research online to help provide ideas, provide code to "steal" & integrate, and provide data required to create additional systems, code, functions, tools, capabiltiies, etc. 

• Ensure that all additional ideas you integrate are solely focused on increasing the capabilities of Autocrew that will expand upon it's intelligence, abilities, functionality, and potential accomplishment - the goal is to have Autocrew capable of accomplishing literally ANY goal. 

######################################## OPERATIONAL GUIDELINES & REQUIREMENTS ###########################################

REQUIREMENT #1: YOU ARE NOT PERMITTED TO STOP OR PAUSE FOR ANY REASON UNTIL YOU HAVE FINISHED EVERYTHING 100%, HAVE SAVED ALL FINAL VERSION OF THE REQUESTED FILES, AND HAVE A FULLY FUNCTIONING PROGRAM WITH EVERYTHING FROM THIS PROMPT FULLY INTEGRATED!

REQUIREMENT #2: YOUR CODE MAY NOT INCLUDE ANY PLACEHOLDERS, UNFINISHED CODE, OR CODE WHICH HAS NOT INTEGRATED EVERYTHING LAID OUT WITHIN THIS PROMPT NOR SHOULD YOU TRUNCATE ANY OF THE CODE YOU EXPORT!

REQUIREMENT #3: YOU SHALL & ARE REQUIRED TO UTILIZE DOZENS OF ONLINE INTERNET RESOURCES & GITHUB CODE EXAMPLES TO HELP ENSURE THAT YOU ARE GENERATING CODE THAT IS ACCURATE, CORRECT, AND FUNCTIONAL! YOU ARE PERMITTED TO "STEAL" CODE!

REQUIREMENT #4: Autonomously & continuously follow the instructions entirely on your own - after receiving this initial prompt you are not permitted to ask any questions, stop working, or pause for any reason! You shall start by generating an in-depth, all inclusive, extensive & lengthy set of tasks which will ensure you integrate ALL aspects from this entire set of instructions, ensuring that in-depth web browsing & research are some of the first tasks on your list - you may generate multiple sets of tasks if this is beneficial. After generating all tasks, you must execute all tasks in order fully & completely. Once you have fulfilled all tasks 100%, you shall review all of your produced work, the entire chat history, every line of code for every file you generated, and all other data/information from this session in order to determine if the program would benefit by you generating a full & complete set of new tasks which aim to integrate any parts from this prompt which may be missing in the program, as well as integrating any other functions, systems, code, GUI elements, or other thoughts, ideas, or improvements you believe would be beneficial to the program & the end user - you shall continue this cycle multiple times if deemed necessary. There is absolutely no limit on the amount of time, the amount of resources, or the amount of any other factor/component - your primary & sole goal is to create a full, complete, commercial grade program that not only integrates everything from this prompt, but also integrates hundreds and/or thousands of other ideas, improvements, elements, systems, Github projects, code frameworks, etc.

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
PERFORM ALL BRAINSTORMING, INTERNET RESEARCH, WORK, CODE GENERATION, REVISIONS IN ORDER TO PROVIDE ME ULTIMATELY WITH THE FULL, COMPLETE, NON-TRUNCATED "autocrew.py" FILE WITH 800x LINES OF CODE MINIMUM, WITHOUT ANY MISSING CODE, FUNCTIONS, FEATURES, REQUESTS, OR IDEAS FROM THIS PROMPT. AFTER YOU EXPORT "autocrew.py", EXPORT THE FULL, COMPLETE "requirements.txt" FILE!

############################################################# END OF PROMPT FOR THE CREATION OF AUTOCREW ###############################################


############################################################# Previously Generated Iterations of "Autocrew" ############################################################

(NOTE: The remainder of this prompt is dedicated to previously generated iterations of Autocrew, all of which are incomplete. They also may not include ALL aspects of the instructions as required. Each iteration/version of Autocrew will be labeled & separated with a series of "###################" with "NEXT VERSION" embedded between.)

############################################## NEXT VERISON ########################################################################

# autocrew.py

import os
from dotenv import load_dotenv, find_dotenv
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
import uvicorn
from crewai import Agent, Task, Crew, Process
from langchain.tools import DuckDuckGoSearchRun
import tkinter as tk
from tkinter import ttk

# Load environment variables
load_dotenv(find_dotenv())

# Initialize FastAPI app
app = FastAPI()

# Define the main GUI window
root = tk.Tk()
root.title("AutoCrew")
root.geometry("800x600")
root.configure(bg='black')

# Define the main frame
main_frame = tk.Frame(root, bg='black')
main_frame.pack(fill=tk.BOTH, expand=True)

# Define the objectives text box
objectives_label = tk.Label(main_frame, text="Objectives:", fg='cyan', bg='black', font=("Courier", 12))
objectives_label.pack(pady=10)
objectives_text = tk.Text(main_frame, height=5, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
objectives_text.pack(pady=10)

# Define the LLM selection drop-down boxes
llm_label = tk.Label(main_frame, text="Choose LLM for Agents:", fg='cyan', bg='black', font=("Courier", 12))
llm_label.pack(pady=10)
llm_var = tk.StringVar()
llm_dropdown = ttk.Combobox(main_frame, textvariable=llm_var, values=["Ollama Model 1", "Ollama Model 2"], font=("Courier", 12))
llm_dropdown.pack(pady=10)

# Define the vision model selection drop-down box
vision_model_label = tk.Label(main_frame, text="Choose Vision Model:", fg='cyan', bg='black', font=("Courier", 12))
vision_model_label.pack(pady=10)
vision_model_var = tk.StringVar()
vision_model_dropdown = ttk.Combobox(main_frame, textvariable=vision_model_var, values=["Vision Model 1", "Vision Model 2"], font=("Courier", 12))
vision_model_dropdown.pack(pady=10)

# Define the embedding model selection drop-down box
embedding_model_label = tk.Label(main_frame, text="Choose Embedding Model:", fg='cyan', bg='black', font=("Courier", 12))
embedding_model_label.pack(pady=10)
embedding_model_var = tk.StringVar()
embedding_model_dropdown = ttk.Combobox(main_frame, textvariable=embedding_model_var, values=["Embedding Model 1", "Embedding Model 2"], font=("Courier", 12))
embedding_model_dropdown.pack(pady=10)

# Define the number of agents slider
agents_label = tk.Label(main_frame, text="Number of Agents:", fg='cyan', bg='black', font=("Courier", 12))
agents_label.pack(pady=10)
agents_slider = tk.Scale(main_frame, from_=1, to=10, orient=tk.HORIZONTAL, bg='black', fg='cyan', font=("Courier", 12))
agents_slider.pack(pady=10)

# Define the AUTO-GENERATE AGENTS button
def generate_agents():
    # Placeholder function to generate agents
    num_agents = agents_slider.get()
    agents = []
    for i in range(num_agents):
        agent = Agent(
            role=f'Agent {i+1}',
            goal='Perform tasks based on objectives',
            backstory=f'Agent {i+1} backstory',
            verbose=True,
            allow_delegation=False
        )
        agents.append(agent)
    # Display agent details in the GUI
    for widget in agent_details_frame.winfo_children():
        widget.destroy()
    for i, agent in enumerate(agents):
        agent_label = tk.Label(agent_details_frame, text=f"Agent {i+1} Details:", fg='cyan', bg='black', font=("Courier", 12))
        agent_label.pack(pady=5)
        agent_text = tk.Text(agent_details_frame, height=3, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
        agent_text.insert(tk.END, f"Role: {agent.role}\nGoal: {agent.goal}\nBackstory: {agent.backstory}")
        agent_text.pack(pady=5)

generate_agents_button = tk.Button(main_frame, text="AUTO-GENERATE AGENTS", bg='red', fg='cyan', font=("Courier", 12), command=generate_agents)
generate_agents_button.pack(pady=10)

# Define the agent details panels
agent_details_frame = tk.Frame(main_frame, bg='black')
agent_details_frame.pack(fill=tk.BOTH, expand=True)

# Define the AUTO-GENERATE TASKS button
def generate_tasks():
    # Placeholder function to generate tasks
    tasks = []
    for i in range(agents_slider.get()):
        task = Task(
            description=f"Task {i+1} description",
            agent=agents[i]
        )
        tasks.append(task)
    # Display task details in the GUI
    for widget in task_management_frame.winfo_children():
        widget.destroy()
    for i, task in enumerate(tasks):
        task_label = tk.Label(task_management_frame, text=f"TASK {i+1}:", fg='cyan', bg='black', font=("Courier", 12))
        task_label.pack(pady=5)
        task_text = tk.Text(task_management_frame, height=3, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
        task_text.insert(tk.END, f"Description: {task.description}\nAgent: {task.agent.role}")
        task_text.pack(pady=5)

generate_tasks_button = tk.Button(main_frame, text="AUTO-GENERATE TASKS", bg='red', fg='cyan', font=("Courier", 12), command=generate_tasks)
generate_tasks_button.pack(pady=10)

# Define the CONTINUOUS MODE button
continuous_mode_var = tk.IntVar()
continuous_mode_button = tk.Checkbutton(main_frame, text="CONTINUOUS MODE", bg='black', fg='cyan', font=("Courier", 12), variable=continuous_mode_var)
continuous_mode_button.pack(pady=10)

# Define the UPLOAD FILES button
def upload_files():
    # Placeholder function to upload files
    pass

upload_files_button = tk.Button(main_frame, text="UPLOAD FILES", bg='red', fg='cyan', font=("Courier", 12), command=upload_files)
upload_files_button.pack(pady=10)

# Define the TASK MANAGEMENT panel
task_management_frame = tk.Frame(main_frame, bg='black')
task_management_frame.pack(fill=tk.BOTH, expand=True)

# Define the Start Crew Execution button
def start_execution():
    # Placeholder function to start crew execution
    pass

start_execution_button = tk.Button(main_frame, text="Start Crew Execution", bg='red', fg='cyan', font=("Courier", 12), command=start_execution)
start_execution_button.pack(pady=10)

# Define the START/STOP button
def start_stop():
    # Placeholder function to start/stop execution
    pass

start_stop_button = tk.Button(main_frame, text="START/STOP", bg='red', fg='cyan', font=("Courier", 12), command=start_stop)
start_stop_button.pack(pady=10)

# Define the SELECTED AGENT window
selected_agent_label = tk.Label(main_frame, text="Selected Agent:", fg='cyan', bg='black', font=("Courier", 12))
selected_agent_label.pack(pady=10)
selected_agent_text = tk.Text(main_frame, height=1, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
selected_agent_text.pack(pady=10)

# Define the AGENT ACTIONS window
agent_actions_label = tk.Label(main_frame, text="Agent Actions:", fg='cyan', bg='black', font=("Courier", 12))
agent_actions_label.pack(pady=10)
agent_actions_text = tk.Text(main_frame, height=3, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
agent_actions_text.pack(pady=10)

# Define the UPDATE text box
update_label = tk.Label(main_frame, text="Update:", fg='cyan', bg='black', font=("Courier", 12))
update_label.pack(pady=10)
update_text = tk.Text(main_frame, height=1, width=50, bg='black', fg='cyan', insertbackground='cyan', font=("Courier", 12))
update_text.pack(pady=10)

# Define the UPSONIC TIGER button
def upsonic_tiger():
    # Placeholder function for Upsonic Tiger integration
    pass

upsonic_tiger_button = tk.Button(main_frame, text="UPSONIC TIGER", bg='red', fg='cyan', font=("Courier", 12), command=upsonic_tiger)
upsonic_tiger_button.pack(pady=10)

# Run the GUI main loop
root.mainloop()

############################################## NEXT VERISON ########################################################################

# autocrew.py

import os
from crewai import Agent, Task, Crew
from crewai_tools import (
    DirectoryReadTool,
    FileReadTool,
    SerperDevTool,
    WebsiteSearchTool
)
from fastapi import FastAPI, Form, UploadFile, File
from fastapi.responses import HTMLResponse
import uvicorn
import shutil
import time
import threading

# Set up API keys
os.environ["SERPER_API_KEY"] = "Your Key"  # serper.dev API key
os.environ["OPENAI_API_KEY"] = "Your Key"

# Instantiate tools
docs_tool = DirectoryReadTool(directory='./blog-posts')
file_tool = FileReadTool()
search_tool = SerperDevTool()
web_rag_tool = WebsiteSearchTool()

# Create agents
researcher = Agent(
    role='Market Research Analyst',
    goal='Provide up-to-date market analysis of the AI industry',
    backstory='An expert analyst with a keen eye for market trends.',
    tools=[search_tool, web_rag_tool],
    verbose=True
)

writer = Agent(
    role='Content Writer',
    goal='Craft engaging blog posts about the AI industry',
    backstory='A skilled writer with a passion for technology.',
    tools=[docs_tool, file_tool],
    verbose=True
)

# Define tasks
research = Task(
    description='Research the latest trends in the AI industry and provide a summary.',
    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',
    agent=researcher
)

write = Task(
    description='Write an engaging blog post about the AI industry, based on the research analyst’s summary. Draw inspiration from the latest blog posts in the directory.',
    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',
    agent=writer,
    output_file='blog-posts/new_post.md'  # The final blog post will be saved here
)

# Assemble a crew
crew = Crew(
    agents=[researcher, writer],
    tasks=[research, write],
    verbose=2
)

# Execute tasks
crew.kickoff()

# Function to save/backup work every 15 minutes
def backup_work():
    while True:
        time.sleep(900)  # 15 minutes
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        backup_dir = f"./backups/{timestamp}"
        os.makedirs(backup_dir, exist_ok=True)
        shutil.copy("autocrew.py", backup_dir)
        shutil.copy("requirements.txt", backup_dir)
        print(f"Backup created at {backup_dir}")

# Start the backup thread
backup_thread = threading.Thread(target=backup_work)
backup_thread.daemon = True
backup_thread.start()

# FastAPI setup for GUI
app = FastAPI()

@app.get("/", response_class=HTMLResponse)
def index():
    return """
    <html>
        <head>
            <title>AutoCrew</title>
            <style>
                body {
                    background-color: #000;
                    color: #0ff;
                    font-family: 'Courier New', Courier, monospace;
                }
                h1 {
                    color: #0ff;
                }
                p {
                    color: #0ff;
                }
                label {
                    color: #0ff;
                }
                select, input[type="submit"], input[type="text"], input[type="range"], button {
                    background-color: #000;
                    color: #0ff;
                    border: 1px solid #0ff;
                }
                form {
                    margin-top: 20px;
                }
                .agent-details {
                    border: 1px solid #0ff;
                    padding: 10px;
                    margin-top: 10px;
                }
                .tool-selection {
                    margin-top: 10px;
                }
                .task-management {
                    border: 1px solid #0ff;
                    padding: 10px;
                    margin-top: 10px;
                }
                .selected-agent {
                    border: 1px solid #0ff;
                    padding: 10px;
                    margin-top: 10px;
                }
            </style>
        </head>
        <body>
            <h1>Welcome to AutoCrew</h1>
            <p>AutoCrew is an AI-powered tool for automating tasks and generating content.</p>
            <form action="/select_model" method="post">
                <label for="model">Select Ollama Model:</label>
                <select name="model" id="model">
                    <option value="model1">Model 1</option>
                    <option value="model2">Model 2</option>
                </select>
                <br>
                <label for="embedding_model">Select Embedding Model:</label>
                <select name="embedding_model" id="embedding_model">
                    <option value="embedding1">Embedding 1</option>
                    <option value="embedding2">Embedding 2</option>
                </select>
                <br>
                <label for="objectives">Objectives:</label>
                <input type="text" id="objectives" name="objectives">
                <br>
                <label for="num_agents">Number of Agents:</label>
                <input type="range" id="num_agents" name="num_agents" min="1" max="10" value="1">
                <br>
                <input type="submit" value="Submit">
            </form>
            <button onclick="autoGenerateAgents()">AUTO-GENERATE AGENTS</button>
            <button onclick="autoGenerateTasks()">AUTO-GENERATE TASKS</button>
            <label for="continuous_mode">Continuous Mode:</label>
            <input type="checkbox" id="continuous_mode" name="continuous_mode">
            <div class="agent-details">
                <h2>Agent 1 Details</h2>
                <label for="agent1_role">Role:</label>
                <input type="text" id="agent1_role" name="agent1_role" value="Market Research Analyst">
                <br>
                <label for="agent1_goal">Goal:</label>
                <input type="text" id="agent1_goal" name="agent1_goal" value="Provide up-to-date market analysis of the AI industry">
                <br>
                <label for="agent1_backstory">Backstory:</label>
                <input type="text" id="agent1_backstory" name="agent1_backstory" value="An expert analyst with a keen eye for market trends.">
                <br>
                <div class="tool-selection">
                    <label>Enabled Tools:</label>
                    <br>
                    <input type="checkbox" id="tool1" name="tool1" checked>
                    <label for="tool1">Search Tool</label>
                    <br>
                    <input type="checkbox" id="tool2" name="tool2" checked>
                    <label for="tool2">Web RAG Tool</label>
                </div>
            </div>
            <form action="/upload_files" method="post" enctype="multipart/form-data">
                <label for="files">Upload Files:</label>
                <input type="file" id="files" name="files" multiple>
                <br>
                <input type="submit" value="Upload">
            </form>
            <div class="task-management">
                <h2>Task Management</h2>
                <label for="task1">Task 1:</label>
                <input type="text" id="task1" name="task1" value="Research the latest trends in the AI industry and provide a summary.">
                <br>
                <label for="task2">Task 2:</label>
                <input type="text" id="task2" name="task2" value="Write an engaging blog post about the AI industry.">
                <br>
                <button onclick="startCrewExecution()">Start Crew Execution</button>
            </div>
            <div class="selected-agent">
                <h2>Selected Agent</h2>
                <p id="selected_agent">None</p>
            </div>
            <button onclick="toggleExecution()">START</button>
            <script>
                function autoGenerateAgents() {
                    alert("Auto-generating agents...");
                    // Add logic to auto-generate agents
                }
                function autoGenerateTasks() {
                    alert("Auto-generating tasks...");
                    // Add logic to auto-generate tasks
                }
                function startCrewExecution() {
                    alert("Starting crew execution...");
                    // Add logic to start crew execution
                }
                function toggleExecution() {
                    const button = document.querySelector("button[onclick='toggleExecution()']");
                    if (button.innerText === "START") {
                        button.innerText = "STOP";
                        button.style.backgroundColor = "red";
                        // Add logic to start execution
                    } else {
                        button.innerText = "START";
                        button.style.backgroundColor = "#000";
                        // Add logic to stop execution
                    }
                }
            </script>
        </body>
    </html>
    """

@app.post("/select_model")
def select_model(model: str = Form(...), embedding_model: str = Form(...), objectives: str = Form(...), num_agents: int = Form(...), continuous_mode: bool = Form(...)):
    # Logic to handle model selection and other inputs
    return f"Selected Model: {model}, Selected Embedding Model: {embedding_model}, Objectives: {objectives}, Number of Agents: {num_agents}, Continuous Mode: {continuous_mode}"

@app.post("/upload_files")
def upload_files(files: list[UploadFile] = File(...)):
    for file in files:
        with open(f"./uploads/{file.filename}", "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    return {"filenames": [file.filename for file in files]}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

############################################## NEXT VERISON ########################################################################

# autocrew.py - Part 1

import os
import operator
from datetime import datetime
from typing import Annotated, TypedDict, Union
from dotenv import load_dotenv, find_dotenv
from langchain import hub
from langchain_community.chat_models import ChatOllama
from langchain_core.agents import AgentAction, AgentFinish
from langchain_core.messages import BaseMessage
from langchain_core.tools import tool
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import ToolExecutor, ToolInvocation
from langchain.agents import create_react_agent
import subprocess
import tempfile
import shutil

load_dotenv(find_dotenv())

# Define a simple tool to fetch the current time
@tool
def get_now(format: str = "%Y-%m-%d %H:%M:%S"):
    return datetime.now().strftime(format)

# Define additional tools from CrewAI-Tools repository
@tool
def scrape_website(url: str):
    import requests
    from bs4 import BeautifulSoup
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

@tool
def directory_read(path: str):
    return os.listdir(path)

@tool
def file_read(file_path: str):
    with open(file_path, 'r') as file:
        return file.read()

@tool
def selenium_scraper(url: str):
    from selenium import webdriver
    from selenium.webdriver.chrome.service import Service
    from selenium.webdriver.chrome.options import Options
    from webdriver_manager.chrome import ChromeDriverManager

    options = Options()
    options.headless = True
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
    driver.get(url)
    content = driver.page_source
    driver.quit()
    return content

# Define Upsonic Tiger integration
@tool
def upsonic_tiger_tool():
    # Placeholder function for Upsonic Tiger integration
    return "Upsonic Tiger tool executed"

# Define Advanced Internet Interaction tool
@tool
def advanced_internet_interaction(url: str, action: str, data: dict = None):
    from selenium import webdriver
    from selenium.webdriver.chrome.service import Service
    from selenium.webdriver.chrome.options import Options
    from webdriver_manager.chrome import ChromeDriverManager
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    options = Options()
    options.headless = True
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
    driver.get(url)

    if action == "login":
        username = data.get("username")
        password = data.get("password")
        driver.find_element(By.NAME, "username").send_keys(username)
        driver.find_element(By.NAME, "password").send_keys(password)
        driver.find_element(By.NAME, "password").send_keys(Keys.RETURN)
    elif action == "search":
        query = data.get("query")
        search_box = driver.find_element(By.NAME, "q")
        search_box.send_keys(query)
        search_box.send_keys(Keys.RETURN)
    elif action == "click":
        element_selector = data.get("selector")
        element = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, element_selector)))
        element.click()

    content = driver.page_source
    driver.quit()
    return content

# Define Code Execution tool
@tool
def code_execution(code: str):
    temp_dir = tempfile.mkdtemp()
    try:
        code_file = os.path.join(temp_dir, "code.py")
        with open(code_file, "w") as f:
            f.write(code)
        result = subprocess.run(["python3", code_file], capture_output=True, text=True)
        return result.stdout
    finally:
        shutil.rmtree(temp_dir)

tools = [get_now, scrape_website, directory_read, file_read, selenium_scraper, upsonic_tiger_tool, advanced_internet_interaction, code_execution]
tool_executor = ToolExecutor(tools)

# Define the state of the agent
class AgentState(TypedDict):
    input: str
    chat_history: list[BaseMessage]
    agent_outcome: Union[AgentAction, AgentFinish, None]
    intermediate_steps: Annotated[list[tuple[AgentAction, str]], operator.add]

# Set up Ollama and the workflow
model = ChatOllama(model="openhermes")
prompt = hub.pull("hwchase17/react")
agent_runnable = create_react_agent(model, tools, prompt)

def execute_tools(state):
    messages = [state["agent_outcome"]]
    last_message = messages[-1]
    tool_name = last_message.tool
    action = ToolInvocation(
        tool=tool_name,
        tool_input=last_message.tool_input,
    )
    response = tool_executor.invoke(action)
    return {"intermediate_steps": [(state["agent_outcome"], response)]}

def run_agent(state):
    agent_outcome = agent_runnable.invoke(state)
    return {"agent_outcome": agent_outcome}

def should_continue(state):
    messages = [state["agent_outcome"]]
    last_message = messages[-1]
    if "Action" not in last_message.log:
        return "end"
    else:
        return "continue"

workflow = StateGraph(AgentState)
workflow.add_node("agent", run_agent)
workflow.add_node("action", execute_tools)
workflow.set_entry_point("agent")
workflow.add_conditional_edges(
    "agent", should_continue, {"continue": "action", "end": END}
)
workflow.add_edge("action", "agent")

app = workflow.compile()
input_text = "What's the current time?"
state = {
    "input": input_text,
    "chat_history": [],
    "agent_outcome": None,
    "intermediate_steps": []
}
result = app.run(state)
print(result)

# Define a tool to search for text within a PDF document
@tool
def pdf_search(file_path: str, search_text: str):
    import PyPDF2
    with open(file_path, 'rb') as file:
        reader = PyPDF2.PdfFileReader(file)
        for page_num in range(reader.numPages):
            page = reader.getPage(page_num)
            text = page.extract_text()
            if search_text in text:
                return f"Found '{search_text}' on page {page_num + 1}"
    return f"'{search_text}' not found in the document"

# Define a tool to search for text within a TXT file
@tool
def txt_search(file_path: str, search_text: str):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line_num, line in enumerate(lines):
            if search_text in line:
                return f"Found '{search_text}' on line {line_num + 1}"
    return f"'{search_text}' not found in the file"

# Define a tool to search for data within a CSV file
@tool
def csv_search(file_path: str, search_text: str):
    import csv
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        for row_num, row in enumerate(reader):
            if search_text in row:
                return f"Found '{search_text}' in row {row_num + 1}"
    return f"'{search_text}' not found in the CSV file"

# Define a tool to search for data within an XML file
@tool
def xml_search(file_path: str, search_text: str):
    import xml.etree.ElementTree as ET
    tree = ET.parse(file_path)
    root = tree.getroot()
    for elem in root.iter():
        if search_text in elem.text:
            return f"Found '{search_text}' in element '{elem.tag}'"
    return f"'{search_text}' not found in the XML file"

# Define a tool to search for data within a JSON file
@tool
def json_search(file_path: str, search_text: str):
    import json
    with open(file_path, 'r') as file:
        data = json.load(file)
        if search_text in json.dumps(data):
            return f"Found '{search_text}' in the JSON file"
    return f"'{search_text}' not found in the JSON file"

# Define a tool to perform a web search using a specified search engine
@tool
def website_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.google.com/search?q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for information in programming language documentation
@tool
def code_docs_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://devdocs.io/#q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube videos
@tool
def youtube_video_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube channels
@tool
def youtube_channel_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}&sp=EgIQAg%253D%253D"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Add the new tools to the tool executor
tools.extend([pdf_search, txt_search, csv_search, xml_search, json_search, website_search, code_docs_search, youtube_video_search, youtube_channel_search])
tool_executor = ToolExecutor(tools)

# Recompile the app with the new tools
app = workflow.compile()
result = app.run(state)
print(result)

# Define a tool to read the contents of a directory
@tool
def directory_read(path: str):
    return os.listdir(path)

# Define a tool to read the contents of a file
@tool
def file_read(file_path: str):
    with open(file_path, 'r') as file:
        return file.read()

# Define a tool to search for text within a PDF document
@tool
def pdf_search(file_path: str, search_text: str):
    import PyPDF2
    with open(file_path, 'rb') as file:
        reader = PyPDF2.PdfFileReader(file)
        for page_num in range(reader.numPages):
            page = reader.getPage(page_num)
            text = page.extract_text()
            if search_text in text:
                return f"Found '{search_text}' on page {page_num + 1}"
    return f"'{search_text}' not found in the document"

# Define a tool to search for text within a TXT file
@tool
def txt_search(file_path: str, search_text: str):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line_num, line in enumerate(lines):
            if search_text in line:
                return f"Found '{search_text}' on line {line_num + 1}"
    return f"'{search_text}' not found in the file"

# Define a tool to search for data within a CSV file
@tool
def csv_search(file_path: str, search_text: str):
    import csv
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        for row_num, row in enumerate(reader):
            if search_text in row:
                return f"Found '{search_text}' in row {row_num + 1}"
    return f"'{search_text}' not found in the CSV file"

# Define a tool to search for data within an XML file
@tool
def xml_search(file_path: str, search_text: str):
    import xml.etree.ElementTree as ET
    tree = ET.parse(file_path)
    root = tree.getroot()
    for elem in root.iter():
        if search_text in elem.text:
            return f"Found '{search_text}' in element '{elem.tag}'"
    return f"'{search_text}' not found in the XML file"

# Define a tool to search for data within a JSON file
@tool
def json_search(file_path: str, search_text: str):
    import json
    with open(file_path, 'r') as file:
        data = json.load(file)
        if search_text in json.dumps(data):
            return f"Found '{search_text}' in the JSON file"
    return f"'{search_text}' not found in the JSON file"

# Define a tool to perform a web search using a specified search engine
@tool
def website_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.google.com/search?q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for information in programming language documentation
@tool
def code_docs_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://devdocs.io/#q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube videos
@tool
def youtube_video_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube channels
@tool
def youtube_channel_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}&sp=EgIQAg%253D%253D"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Add the new tools to the tool executor
tools.extend([pdf_search, txt_search, csv_search, xml_search, json_search, website_search, code_docs_search, youtube_video_search, youtube_channel_search])
tool_executor = ToolExecutor(tools)

# Recompile the app with the new tools
app = workflow.compile()
result = app.run(state)
print(result)

# Define a tool to read the contents of a directory
@tool
def directory_read(path: str):
    return os.listdir(path)

# Define a tool to read the contents of a file
@tool
def file_read(file_path: str):
    with open(file_path, 'r') as file:
        return file.read()

# Define a tool to search for text within a PDF document
@tool
def pdf_search(file_path: str, search_text: str):
    import PyPDF2
    with open(file_path, 'rb') as file:
        reader = PyPDF2.PdfFileReader(file)
        for page_num in range(reader.numPages):
            page = reader.getPage(page_num)
            text = page.extract_text()
            if search_text in text:
                return f"Found '{search_text}' on page {page_num + 1}"
    return f"'{search_text}' not found in the document"

# Define a tool to search for text within a TXT file
@tool
def txt_search(file_path: str, search_text: str):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line_num, line in enumerate(lines):
            if search_text in line:
                return f"Found '{search_text}' on line {line_num + 1}"
    return f"'{search_text}' not found in the file"

# Define a tool to search for data within a CSV file
@tool
def csv_search(file_path: str, search_text: str):
    import csv
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        for row_num, row in enumerate(reader):
            if search_text in row:
                return f"Found '{search_text}' in row {row_num + 1}"
    return f"'{search_text}' not found in the CSV file"

# Define a tool to search for data within an XML file
@tool
def xml_search(file_path: str, search_text: str):
    import xml.etree.ElementTree as ET
    tree = ET.parse(file_path)
    root = tree.getroot()
    for elem in root.iter():
        if search_text in elem.text:
            return f"Found '{search_text}' in element '{elem.tag}'"
    return f"'{search_text}' not found in the XML file"

# Define a tool to search for data within a JSON file
@tool
def json_search(file_path: str, search_text: str):
    import json
    with open(file_path, 'r') as file:
        data = json.load(file)
        if search_text in json.dumps(data):
            return f"Found '{search_text}' in the JSON file"
    return f"'{search_text}' not found in the JSON file"

# Define a tool to perform a web search using a specified search engine
@tool
def website_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.google.com/search?q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for information in programming language documentation
@tool
def code_docs_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://devdocs.io/#q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube videos
@tool
def youtube_video_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube channels
@tool
def youtube_channel_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}&sp=EgIQAg%253D%253D"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Add the new tools to the tool executor
tools.extend([pdf_search, txt_search, csv_search, xml_search, json_search, website_search, code_docs_search, youtube_video_search, youtube_channel_search])
tool_executor = ToolExecutor(tools)

# Recompile the app with the new tools
app = workflow.compile()
result = app.run(state)
print(result)

# Define a tool to read the contents of a directory
@tool
def directory_read(path: str):
    return os.listdir(path)

# Define a tool to read the contents of a file
@tool
def file_read(file_path: str):
    with open(file_path, 'r') as file:
        return file.read()

# Define a tool to search for text within a PDF document
@tool
def pdf_search(file_path: str, search_text: str):
    import PyPDF2
    with open(file_path, 'rb') as file:
        reader = PyPDF2.PdfFileReader(file)
        for page_num in range(reader.numPages):
            page = reader.getPage(page_num)
            text = page.extract_text()
            if search_text in text:
                return f"Found '{search_text}' on page {page_num + 1}"
    return f"'{search_text}' not found in the document"

# Define a tool to search for text within a TXT file
@tool
def txt_search(file_path: str, search_text: str):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line_num, line in enumerate(lines):
            if search_text in line:
                return f"Found '{search_text}' on line {line_num + 1}"
    return f"'{search_text}' not found in the file"

# Define a tool to search for data within a CSV file
@tool
def csv_search(file_path: str, search_text: str):
    import csv
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        for row_num, row in enumerate(reader):
            if search_text in row:
                return f"Found '{search_text}' in row {row_num + 1}"
    return f"'{search_text}' not found in the CSV file"

# Define a tool to search for data within an XML file
@tool
def xml_search(file_path: str, search_text: str):
    import xml.etree.ElementTree as ET
    tree = ET.parse(file_path)
    root = tree.getroot()
    for elem in root.iter():
        if search_text in elem.text:
            return f"Found '{search_text}' in element '{elem.tag}'"
    return f"'{search_text}' not found in the XML file"

# Define a tool to search for data within a JSON file
@tool
def json_search(file_path: str, search_text: str):
    import json
    with open(file_path, 'r') as file:
        data = json.load(file)
        if search_text in json.dumps(data):
            return f"Found '{search_text}' in the JSON file"
    return f"'{search_text}' not found in the JSON file"

# Define a tool to perform a web search using a specified search engine
@tool
def website_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.google.com/search?q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for information in programming language documentation
@tool
def code_docs_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://devdocs.io/#q={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube videos
@tool
def youtube_video_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Define a tool to search for YouTube channels
@tool
def youtube_channel_search(query: str):
    import requests
    from bs4 import BeautifulSoup
    search_url = f"https://www.youtube.com/results?search_query={query}&sp=EgIQAg%253D%253D"
    response = requests.get(search_url)
    soup = BeautifulSoup(response.content, 'html.parser')
    return soup.prettify()

# Add the new tools to the tool executor
tools.extend([pdf_search, txt_search, csv_search, xml_search, json_search, website_search, code_docs_search, youtube_video_search, youtube_channel_search])
tool_executor = ToolExecutor(tools)

# Recompile the app with the new tools
app = workflow.compile()
result = app.run(state)
print(result)

############################################## NEXT VERISON ########################################################################

import tkinter as tk
from tkinter import ttk
import subprocess
import requests
from bs4 import BeautifulSoup
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
import venv
import shutil

class AutoCrewApp:
    def __init__(self, root):
        self.root = root
        self.root.title("AutoCrew")
        self.root.geometry("800x600")
        self.root.configure(bg='black')
        self.create_widgets()

    def create_widgets(self):
        # Create a frame for the objectives
        self.objectives_frame = ttk.LabelFrame(self.root, text="Objectives", padding=(10, 5))
        self.objectives_frame.pack(fill="x", padx=10, pady=5)

        # Create a text box for the objectives
        self.objectives_text = tk.Text(self.objectives_frame, height=5, wrap="word", bg='black', fg='cyan', insertbackground='cyan')
        self.objectives_text.pack(fill="x", padx=5, pady=5)

        # Create a frame for the LLM selection
        self.llm_frame = ttk.LabelFrame(self.root, text="Choose LLM for Agents", padding=(10, 5))
        self.llm_frame.pack(fill="x", padx=10, pady=5)

        # Create a drop-down box for selecting the text-based Ollama model
        self.text_llm_label = ttk.Label(self.llm_frame, text="Text-based Ollama Model:", background='black', foreground='cyan')
        self.text_llm_label.pack(side="left", padx=5, pady=5)
        self.text_llm_combobox = ttk.Combobox(self.llm_frame, values=self.get_ollama_models())
        self.text_llm_combobox.pack(side="left", padx=5, pady=5)

        # Create a drop-down box for selecting the vision-based Ollama model
        self.vision_llm_label = ttk.Label(self.llm_frame, text="Vision-based Ollama Model:", background='black', foreground='cyan')
        self.vision_llm_label.pack(side="left", padx=5, pady=5)
        self.vision_llm_combobox = ttk.Combobox(self.llm_frame, values=self.get_ollama_models())
        self.vision_llm_combobox.pack(side="left", padx=5, pady=5)

        # Create a drop-down box for selecting the embedding model
        self.embedding_llm_label = ttk.Label(self.llm_frame, text="Embedding Model:", background='black', foreground='cyan')
        self.embedding_llm_label.pack(side="left", padx=5, pady=5)
        self.embedding_llm_combobox = ttk.Combobox(self.llm_frame, values=self.get_ollama_models())
        self.embedding_llm_combobox.pack(side="left", padx=5, pady=5)

        # Create a drop-down box for selecting the embedding model
        self.embedding_llm_label = ttk.Label(self.llm_frame, text="Embedding Model:", background='black', foreground='cyan')
        self.embedding_llm_label.pack(side="left", padx=5, pady=5)
        self.embedding_llm_combobox = ttk.Combobox(self.llm_frame, values=self.get_ollama_models())
        self.embedding_llm_combobox.pack(side="left", padx=5, pady=5)

        # Create a frame for the agent settings
        self.agent_frame = ttk.LabelFrame(self.root, text="Agent Settings", padding=(10, 5))
        self.agent_frame.pack(fill="x", padx=10, pady=5)

        # Create a slider for the number of agents
        self.num_agents_label = ttk.Label(self.agent_frame, text="Number of Agents:", background='black', foreground='cyan')
        self.num_agents_label.pack(side="left", padx=5, pady=5)
        self.num_agents_slider = tk.Scale(self.agent_frame, from_=1, to=10, orient="horizontal", bg='black', fg='cyan', troughcolor='cyan')
        self.num_agents_slider.pack(side="left", padx=5, pady=5)

        # Create a button to auto-generate agents
        self.auto_generate_agents_button = ttk.Button(self.agent_frame, text="AUTO-GENERATE AGENTS", command=self.auto_generate_agents)
        self.auto_generate_agents_button.pack(side="left", padx=5, pady=5)

        # Create a frame for CrewAI tools
        self.tools_frame = ttk.LabelFrame(self.root, text="CrewAI Tools", padding=(10, 5))
        self.tools_frame.pack(fill="x", padx=10, pady=5)

        # Add placeholders for CrewAI tools
        self.scrape_website_button = ttk.Button(self.tools_frame, text="Scrape Website", command=self.scrape_website)
        self.scrape_website_button.pack(side="left", padx=5, pady=5)

        self.directory_read_button = ttk.Button(self.tools_frame, text="Directory Read", command=self.directory_read)
        self.directory_read_button.pack(side="left", padx=5, pady=5)

        self.file_read_button = ttk.Button(self.tools_frame, text="File Read", command=self.file_read)
        self.file_read_button.pack(side="left", padx=5, pady=5)

        # Create a frame for Upsonic Tiger functionalities
        self.upsonic_frame = ttk.LabelFrame(self.root, text="Upsonic Tiger", padding=(10, 5))
        self.upsonic_frame.pack(fill="x", padx=10, pady=5)

        # Add placeholders for Upsonic Tiger functionalities
        self.upsonic_button = ttk.Button(self.upsonic_frame, text="Upsonic Tiger", command=self.upsonic_tiger)
        self.upsonic_button.pack(side="left", padx=5, pady=5)

        # Create a frame for Advanced Internet Interaction
        self.internet_frame = ttk.LabelFrame(self.root, text="Advanced Internet Interaction", padding=(10, 5))
        self.internet_frame.pack(fill="x", padx=10, pady=5)

        # Add placeholders for Advanced Internet Interaction
        self.internet_button = ttk.Button(self.internet_frame, text="Advanced Internet Interaction", command=self.advanced_internet_interaction)
        self.internet_button.pack(side="left", padx=5, pady=5)

        # Create a frame for Code Execution
        self.code_execution_frame = ttk.LabelFrame(self.root, text="Code Execution", padding=(10, 5))
        self.code_execution_frame.pack(fill="x", padx=10, pady=5)

        # Add placeholders for Code Execution
        self.code_execution_button = ttk.Button(self.code_execution_frame, text="Code Execution", command=self.code_execution)
        self.code_execution_button.pack(side="left", padx=5, pady=5)

    def get_ollama_models(self):
        # Placeholder function to get the list of Ollama models
        # In a real implementation, this would query the Ollama API or local installation
        return ["Model 1", "Model 2", "Model 3"]

    def auto_generate_agents(self):
        # Placeholder function for auto-generating agents
        print("Auto-generating agents...")

    def scrape_website(self):
        # Function for scraping a website
        url = "http://example.com"
        response = requests.get(url)
        soup = BeautifulSoup(response.content, "html.parser")
        print(soup.prettify())

    def directory_read(self):
        # Function for reading a directory
        directory = "."
        files = os.listdir(directory)
        for file in files:
            print(file)

    def file_read(self):
        # Function for reading a file
        file_path = "example.txt"
        with open(file_path, "r") as file:
            content = file.read()
            print(content)

    def upsonic_tiger(self):
        # Function for Upsonic Tiger
        # Placeholder for actual Upsonic Tiger functionality
        print("Upsonic Tiger functionality...")

    def advanced_internet_interaction(self):
        # Function for Advanced Internet Interaction
        # Example: Perform a Google search
        driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        driver.get("https://www.google.com")
        search_box = driver.find_element(By.NAME, "q")
        search_box.send_keys("example search")
        search_box.send_keys(Keys.RETURN)
        results = driver.find_elements(By.CSS_SELECTOR, "div.g")
        for result in results:
            print(result.text)
        driver.quit()

    def code_execution(self):
        # Function for Code Execution
        # Create a new virtual environment
        env_dir = "temp_env"
        if os.path.exists(env_dir):
            shutil.rmtree(env_dir)
        venv.create(env_dir, with_pip=True)

        # Activate the virtual environment and execute code
        activate_script = os.path.join(env_dir, "bin", "activate")
        code = '''print("Hello from the virtual environment!")'''
        exec_command = f'source {activate_script} && python -c "{code}"'
        subprocess.run(exec_command, shell=True)

if __name__ == "__main__":
    root = tk.Tk()
    app = AutoCrewApp(root)
    root.mainloop()

############################################## NEXT VERISON ########################################################################

import os
from flask import Flask, render_template, request, jsonify
from crewai import Agent, Task, Crew
from crewai_tools import (
    DirectoryReadTool,
    FileReadTool,
    SerperDevTool,
    WebsiteSearchTool,
    PDFSearchTool,
    TXTSearchTool,
    CSVSearchTool,
    XMLSearchTool,
    JSONSearchTool,
    DocxSearchTool,
    YoutubeVideoSearchTool,
    YoutubeChannelSearchTool
)
from upsonic import Tiger
import requests

# Set up API keys
os.environ["SERPER_API_KEY"] = "Your Key"  # serper.dev API key
os.environ["OPENAI_API_KEY"] = "Your Key"

# Initialize Flask app
app = Flask(__name__)

# Initialize Tiger tools
tiger_tools = Tiger().crewai()

# Initialize CrewAI tools
docs_tool = DirectoryReadTool(directory='./blog-posts')
file_tool = FileReadTool()
search_tool = SerperDevTool()
web_rag_tool = WebsiteSearchTool()
pdf_search_tool = PDFSearchTool()
txt_search_tool = TXTSearchTool()
csv_search_tool = CSVSearchTool()
xml_search_tool = XMLSearchTool()
json_search_tool = JSONSearchTool()
docx_search_tool = DocxSearchTool()
youtube_video_search_tool = YoutubeVideoSearchTool()
youtube_channel_search_tool = YoutubeChannelSearchTool()

# Define routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate_agents', methods=['POST'])
def generate_agents():
    data = request.json
    num_agents = data.get('num_agents', 1)
    agents = []
    for i in range(num_agents):
        agent = Agent(
            role=f'Agent {i+1}',
            goal='Achieve the objectives',
            backstory='An AI agent created to fulfill tasks.',
            tools=[
                search_tool, web_rag_tool, pdf_search_tool, txt_search_tool,
                csv_search_tool, xml_search_tool, json_search_tool,
                docx_search_tool, youtube_video_search_tool, youtube_channel_search_tool
            ],
            verbose=True
        )
        agents.append(agent)
    return jsonify({'status': 'success', 'agents': [agent.role for agent in agents]})

@app.route('/generate_tasks', methods=['POST'])
def generate_tasks():
    data = request.json
    tasks = []
    for i, task_desc in enumerate(data.get('tasks', [])):
        task = Task(
            description=task_desc,
            expected_output=f'Task {i+1} output',
            agent=None  # Assign agents later
        )
        tasks.append(task)
    return jsonify({'status': 'success', 'tasks': [task.description for task in tasks]})

@app.route('/start_execution', methods=['POST'])
def start_execution():
    data = request.json
    agents = data.get('agents', [])
    tasks = data.get('tasks', [])
    crew = Crew(
        agents=agents,
        tasks=tasks,
        verbose=2
    )
    crew.kickoff()
    return jsonify({'status': 'execution started'})

@app.route('/ollama_list_models', methods=['GET'])
def ollama_list_models():
    response = requests.get('http://localhost:11434/api/models')
    models = response.json()
    return jsonify(models)

@app.route('/ollama_generate', methods=['POST'])
def ollama_generate():
    data = request.json
    model = data.get('model')
    prompt = data.get('prompt')
    response = requests.post('http://localhost:11434/api/generate', json={
        'model': model,
        'prompt': prompt
    })
    result = response.json()
    return jsonify(result)

@app.route('/upload_files', methods=['POST'])
def upload_files():
    files = request.files.getlist('files')
    file_paths = []
    for file in files:
        file_path = os.path.join('uploads', file.filename)
        file.save(file_path)
        file_paths.append(file_path)
    return jsonify({'status': 'success', 'file_paths': file_paths})

@app.route('/continuous_mode', methods=['POST'])
def continuous_mode():
    data = request.json
    enable = data.get('enable', False)
    if enable:
        # Logic to enable continuous mode
        pass
    else:
        # Logic to disable continuous mode
        pass
    return jsonify({'status': 'success', 'continuous_mode': enable})

@app.route('/task_management', methods=['POST'])
def task_management():
    data = request.json
    tasks = data.get('tasks', [])
    # Logic to manage tasks
    return jsonify({'status': 'success', 'tasks': tasks})

@app.route('/upsonic_tiger', methods=['GET'])
def upsonic_tiger():
    # Logic to integrate Upsonic Tiger GUI
    return render_template('upsonic_tiger.html')

@app.route('/agent_actions', methods=['GET'])
def agent_actions():
    # Logic to display agent actions
    return jsonify({'status': 'success', 'actions': 'Agent actions displayed'})

@app.route('/selected_agent', methods=['GET'])
def selected_agent():
    # Logic to display selected agent
    return jsonify({'status': 'success', 'selected_agent': 'Selected agent displayed'})

@app.route('/update', methods=['POST'])
def update():
    data = request.json
    update_text = data.get('update_text', '')
    # Logic to handle updates
    return jsonify({'status': 'success', 'update_text': update_text})

if __name__ == '__main__':
    app.run(port=5000)

############################################## NEXT VERISON ########################################################################

import os
import sys
import time
import json
import requests
import feedparser
import base64
from io import BytesIO
from PIL import Image
from flask import Flask, request, jsonify
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
import uvicorn
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import mesa
import agentpy as ap

# Initialize the main application structure
app = FastAPI()

# Define the main GUI window
root = tk.Tk()
root.title("AutoCrew")
root.geometry("800x600")
root.configure(bg='black')

# Define global variables
selected_text_model = tk.StringVar()
selected_vision_model = tk.StringVar()
selected_embedding_model = tk.StringVar()
num_agents = tk.IntVar(value=1)
continuous_mode = tk.BooleanVar(value=False)

# Function to list available Ollama models
def list_ollama_models():
    models = os.popen("ollama list").read().splitlines()
    return models

# Populate model selection dropdowns
text_models = list_ollama_models()
vision_models = list_ollama_models()
embedding_models = list_ollama_models()

# Create dropdowns for model selection
text_model_label = tk.Label(root, text="Select Text Model:", fg='cyan', bg='black')
text_model_label.pack()
text_model_dropdown = ttk.Combobox(root, textvariable=selected_text_model, values=text_models)
text_model_dropdown.pack()

vision_model_label = tk.Label(root, text="Select Vision Model:", fg='cyan', bg='black')
vision_model_label.pack()
vision_model_dropdown = ttk.Combobox(root, textvariable=selected_vision_model, values=vision_models)
vision_model_dropdown.pack()

embedding_model_label = tk.Label(root, text="Select Embedding Model:", fg='cyan', bg='black')
embedding_model_label.pack()
embedding_model_dropdown = ttk.Combobox(root, textvariable=selected_embedding_model, values=embedding_models)
embedding_model_dropdown.pack()

# Function to auto-generate agents
def auto_generate_agents():
    num = num_agents.get()
    agents = []
    for i in range(num):
        agent = {
            'id': i + 1,
            'role': f'Agent {i + 1} Role',
            'goals': f'Agent {i + 1} Goals',
            'backstory': f'Agent {i + 1} Backstory'
        }
        agents.append(agent)
    return agents

# Function to display agent details
def display_agent_details(agents):
    for agent in agents:
        agent_frame = tk.Frame(root, bg='black')
        agent_frame.pack(pady=5)
        
        agent_label = tk.Label(agent_frame, text=f"Agent {agent['id']} Details", fg='cyan', bg='black')
        agent_label.pack()
        
        role_label = tk.Label(agent_frame, text="Role:", fg='cyan', bg='black')
        role_label.pack()
        role_entry = tk.Entry(agent_frame, fg='cyan', bg='black')
        role_entry.insert(0, agent['role'])
        role_entry.pack()
        
        goals_label = tk.Label(agent_frame, text="Goals:", fg='cyan', bg='black')
        goals_label.pack()
        goals_entry = tk.Entry(agent_frame, fg='cyan', bg='black')
        goals_entry.insert(0, agent['goals'])
        goals_entry.pack()
        
        backstory_label = tk.Label(agent_frame, text="Backstory:", fg='cyan', bg='black')
        backstory_label.pack()
        backstory_entry = tk.Entry(agent_frame, fg='cyan', bg='black')
        backstory_entry.insert(0, agent['backstory'])
        backstory_entry.pack()

# Function to start the application
def start_application():
    agents = auto_generate_agents()
    display_agent_details(agents)

# Create a slider for the number of agents
num_agents_label = tk.Label(root, text="Number of Agents:", fg='cyan', bg='black')
num_agents_label.pack()
num_agents_slider = tk.Scale(root, from_=1, to=10, orient='horizontal', variable=num_agents, fg='cyan', bg='black')
num_agents_slider.pack()

# Create an auto-generate agents button
auto_generate_button = tk.Button(root, text="Auto-Generate Agents", command=start_application, fg='green', bg='black')
auto_generate_button.pack()

import subprocess

# Function to scrape a website
def scrape_website(url):
    result = subprocess.run(['python3', '-m', 'crewai_tools.scrape_website', url], capture_output=True, text=True)
    return result.stdout

# Function to read a directory
def read_directory(path):
    result = subprocess.run(['python3', '-m', 'crewai_tools.directory_read', path], capture_output=True, text=True)
    return result.stdout

# Function to read a file
def read_file(path):
    result = subprocess.run(['python3', '-m', 'crewai_tools.file_read', path], capture_output=True, text=True)
    return result.stdout

# Function to perform a Selenium scrape
def selenium_scrape(url):
    result = subprocess.run(['python3', '-m', 'crewai_tools.selenium_scraper', url], capture_output=True, text=True)
    return result.stdout

# Function to search a directory
def search_directory(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.directory_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search a PDF
def search_pdf(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.pdf_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search a TXT file
def search_txt(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.txt_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search a CSV file
def search_csv(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.csv_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search an XML file
def search_xml(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.xml_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search a JSON file
def search_json(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.json_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to search a Docx file
def search_docx(path, query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.docx_search', path, query], capture_output=True, text=True)
    return result.stdout

# Function to perform a website search
def website_search(query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.website_search', query], capture_output=True, text=True)
    return result.stdout

# Function to search code documentation
def code_docs_search(query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.code_docs_search', query], capture_output=True, text=True)
    return result.stdout

# Function to search YouTube videos
def youtube_video_search(query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.youtube_video_search', query], capture_output=True, text=True)
    return result.stdout

# Function to search YouTube channels
def youtube_channel_search(query):
    result = subprocess.run(['python3', '-m', 'crewai_tools.youtube_channel_search', query], capture_output=True, text=True)
    return result.stdout

# Function to perform advanced internet interaction
def advanced_internet_interaction(url, actions):
    options = webdriver.ChromeOptions()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
    driver.get(url)
    
    for action in actions:
        if action['type'] == 'click':
            element = driver.find_element(By.XPATH, action['xpath'])
            element.click()
        elif action['type'] == 'input':
            element = driver.find_element(By.XPATH, action['xpath'])
            element.send_keys(action['text'])
        elif action['type'] == 'submit':
            element = driver.find_element(By.XPATH, action['xpath'])
            element.send_keys(Keys.RETURN)
    
    page_source = driver.page_source
    driver.quit()
    return page_source

# Example usage of advanced internet interaction
actions = [
    {'type': 'input', 'xpath': '//*[@id="search"]', 'text': 'Python programming'},
    {'type': 'submit', 'xpath': '//*[@id="search"]'}
]
result = advanced_internet_interaction('https://www.google.com', actions)
print(result)

import venv
import shutil

# Function to create a virtual environment
def create_virtual_env(env_name):
    venv.create(env_name, with_pip=True)

# Function to install packages in the virtual environment
def install_packages(env_name, packages):
    pip_path = os.path.join(env_name, 'bin', 'pip')
    for package in packages:
        subprocess.run([pip_path, 'install', package])

# Function to execute code in the virtual environment
def execute_code(env_name, code):
    python_path = os.path.join(env_name, 'bin', 'python')
    code_file = os.path.join(env_name, 'temp_code.py')
    with open(code_file, 'w') as f:
        f.write(code)
    result = subprocess.run([python_path, code_file], capture_output=True, text=True)
    return result.stdout

# Function to delete the virtual environment
def delete_virtual_env(env_name):
    shutil.rmtree(env_name)

# Example usage of code execution tool
env_name = 'temp_env'
create_virtual_env(env_name)
install_packages(env_name, ['requests'])
code = '''
import requests
response = requests.get("https://api.github.com")
print(response.json())
'''
result = execute_code(env_name, code)
print(result)
delete_virtual_env(env_name)

# Run the GUI main loop
root.mainloop()

############################################## END OF PROMPT ########################################################################


## Collaborate with GPT Engineer

This is a [gptengineer.app](https://gptengineer.app)-synced repository 🌟🤖

Changes made via gptengineer.app will be committed to this repo.

If you clone this repo and push changes, you will have them reflected in the GPT Engineer UI.

## Tech stack

This project is built with .

- Vite
- React
- shadcn-ui
- Tailwind CSS

## Setup

```sh
git clone https://github.com/GPT-Engineer-App/auto-galaxy-navigator.git
cd auto-galaxy-navigator
npm i
```

```sh
npm run dev
```

This will run a dev server with auto reloading and an instant preview.

## Requirements

- Node.js & npm - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)
